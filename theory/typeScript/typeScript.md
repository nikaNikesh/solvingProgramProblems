# TypeScript 
 — строго типизированный и компилируемый язык, основанный на JS. 
 Он помогает находить логические противоречия за счёт указания типа значений.
 
### Составные части:

- компилятор
- язык программирования
- сервис для редактора (навигация, контекстные подсказки, рефакторинг и тд)
 
### Преимущества:

- предсказуемость   
- уменьшение количества ошибок
- наличие концепции ООП
- полиморфизм
- инкапсуляция 
- модификаторы доступа
- облегчение поддерживания, масштабирования и тестирования

### Установка и инициализация проекта 

**Установить глобально TS:**

`npm install -g typescript`

**Инициализация нового проекта npm:**

`npm init -y` 

- новый проект Node.js и файл package.json с использованием значений по умолчанию

**Установка TypeScript как зависимости:**

`npm install typescript --save-dev`

**Создание файла конфигурации:**

`npx tsc --init`
 
**Проверка версии:** 

`npx tsc -v`

### Компиляция:

в соответствующей директории:

`tsc namefile.ts`

**Автоматическая компиляция:**

`tsc -w namefile.ts`

**Удаление комментариев при компиляции:**

`tsc namefaile.ts --removeComments`

**Объединение файлов:**

`tsc --outFile namefaile.js namefailefirst.ts namefailesecond.ts`

### tsconfig.json

"target" - версия ECMAScript

"module": "commonjs" - импорты в формате require('') - формат системы модулей

"module": "ESNext" - импорты в формате import

"outFile" задает название выходного файла JS

"exclude" позволяет исключить при компиляции определенные файлы

"noEmitOnError": true - не надо генерировать файл javascript, если при компиляции возникли ошибки

"esModuleInterop": true - Требует поддержки со стороны компилятора во время загрузки модулей commonjs в среду es-модулей
    
"forceConsistentCasingInFileNames": true - Заставляет компилятор следить за регистром букв в именах файлов, если OS (Windows) за этим следить не хочет

"strict": true - Для нового проекта это единственное оправданное значение флага, иначе зачем тогда TypeScript
    
"skipLibCheck": true - Просит компилятор не «капризничать» по поводу сторонних библиотек
 
## Типы

- number
- string
- boolean
- bigint — числа больше, чем 253 - 1
- symbol
- Array
- enum - перечисления
- undefined
- null
- any
- unknown
- void — функция не возвращает значения
- never — тип для переменной, у которой отсутствие значение. Обычно используется в качестве возвращаемого типа функций, которые генерируют или возвращают ошибку

### enum

enum - набор именнованных констант, которые описывают определенные состояния.

```typescript
enum Season { Winter, Spring, Summer, Autumn };
```

По умолчанию константы перечисления представляют числовые значения. 
То есть это так называемое числовое перечисление, в котором каждой константе сопоставляется числовое значение.
Фактически эквивалентно следующему:

```typescript
enum Season { Winter=0, Spring=1, Summer=2, Autumn=3 };
```

Хотя можно явным образом переопределить эти значения. 
Так, мы можем задать значение одной константы, тогда значения следующих констант будет увеличиваться на единицу:

```typescript
enum Season { Winter=5, Spring, Summer, Autumn };           // 5, 6, 7, 8
```

Либо можно каждой константе задать свое значение:

```typescript
enum Season { Winter=4, Spring=8, Summer=16, Autumn=32 };   // 4, 8, 16, 32
```

Также можно получить непосредственно текстовое значение:

```typescript
enum Season { Winter=0, Spring=1, Summer=2, Autumn=3 };
var current: string = Season[2];    // 2 - числовое значение Summer
console.log(current);   // Summer
```
Также существуют строковые и смешанные гетерогенные перечисления:

```typescript
enum Season { 
    Winter = 1, 
    Spring = "Весна",
    Summer = 3, 
    Autumn = "Осень"
};
var current: Season = Season.Summer;
console.log(current);           // 3
console.log(Season.Autumn);     // Осень
```

### Работа с функциями 

необязательные параметры идут после основных и помечаются вопр. знаком

```typescript
function getName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + " " + lastName;
    else
        return firstName;
}
  
let name1 = getName("Иван", "Кузнецов");
console.log(name1); // Иван Кузнецов
let name2 = getName("Вася");
console.log(name2); // Вася
```

* необходима проверка наличия значения, чтобы исключить вывод undefined

### Объединения union 

```typescript
let id : number | string;
id = "1345dgg5";
console.log(id); // 1345dgg5
id = 234;
console.log(id);  // 234
```

### strictNullChecks

Включение strictNullChecks помогает обнаруживать и исправлять множество потенциальных ошибок на этапе компиляции, что способствует безопасности и надежности кода.

### ReadonlyArray (неизменяемые массивы)

Нельзя создать через new.

Создать: 

```typescript
const people: ReadonlyArray<string> = ["Tom", "Bob", "Sam"];
```

ИЛИ 

```typescript
const people: readonly string[] = ["Tom", "Bob", "Sam"];
```

### Tuples 

**Кортежи** - набор элементов с заранее известными типами.

### Литеральные типы 

```typescript
const numbers = [1, 3, 5, 7, 9] as const;
```
*массив numbers объявлен как иммутабельный, т.е. его элементы будут иметь литеральный тип.

## ООП

### Абстрактные классы

- невозможно напрямую создать объект класса;
- в абстрактом классе могут быть абстрактные методы, в таком случае производный класс обязан реализовать все абстрактные методы

### Модификаторы доступа 
 Модификаторы доступа позволяют управлять сокрытием состояния объекта и доступом к нему.
 
**public:**
по умолчанию 

**private:**

к св-вам и методам нельзя обратиться извне при создании объекта данного класса 

**protected:**

определяет поля и методы, которые видны только в классах-наследниках

*Используя модификаторы в параметрах конструктора, нам больше не надо явно создать свойства для этих параметров. Свойства создаются автоматически, называются они по имени параметров и имеют те же модификаторы, что и параметры.

```typescript
class Person {
     
    constructor(private name: string, private age: number) {  }
     
    printPerson(): void {
 
        console.log(`Имя: ${this.name}  Возраст: ${this.age}`);
    }
}
```

### Статические поля 

` static retirementAge: number = 65;`
 
 - к статическим методам обращение только через имя класса
 - в статических методах можно обращаться только к статическим полям и методам
 - в статических методах нельзя общаться к нестатическим методам и полям
 - в статических методах нельзя использовать this
 - можно иметь модификаторы доступа
 - наследуются, в таком случае можно обращаться через имя производного класса

## Интерфейс
 Интерфейс определяет свойства и методы, которые объект должен реализовать 
 (определение кастомного типа данных, но без реализации).

 *объект должен реализовывать ВСЕ свойства и методы Интерфейса (за исключением, если свойство необязательное).
 
### Интерфейсы классов 

 `class User implements IUser{}`

 Расширение интерфейса:

 `interface IUser {
    id: number;
    name: string;
}
interface IUser{
    age: number;
}`

### Наследование интерфейса:

`interface ICar extends IMovable {}`

### Оператор instanceOf

С помощью оператора `instanceOf` можно проверить, принадлежит ли объект определенному классу.

## Generics Обобщения

созданы для конкретизации возвращаемого типа.

```typescript
function getId<T>(id: T): T {
     
    return id;
}
```































