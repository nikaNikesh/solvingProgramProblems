# Массив
**Массив** — упорядоченная коллекция данных.

**Создать** (обычно 2-й вариант):

1. let arr = new Array();

2. let arr = []; *можно сразу указать элементы

**Обращаться:**

array[i];

**Добавить:**

array[5] = 'elementIndFive';

Массив хранит элементы **любого типа**. Например: объект, функция. 

**Последний элемент массива:** 

array.at(-1);

### pop/push, shift/unshift

**Очередь** – упорядоченная коллекция элементов, поддерживающая два вида операций:

**push** добавляет элемент в конец

**shift** удаляет (и возвращает) элемент в начале, сдвигая очередь, так что второй элемент становится первым
 

**Стек** – структура данных, поддерживающая: 

**push** добавляет элемент в конец

**pop** удаляет последний элемент и выводит его 

*Массив работает и как очередь, и как стек. 

Метод **unshift** добавляет элемент в начало массива

***pop** и **unshift** могут добавлять сразу несколько элементов 

*работа с концом массива быстрее, чем с началом 

### length

-  можно изменить длину массива, то есть укоротить его
- очистить массив можно: array.length = 0;

### Многомерные массивы
Массивы могут содержать элементы, которые тоже являются массивами. 

Это можно использовать для хранения матриц.

### toString
- в массивах возвращает список элементов, разделённый запятыми

let arr = [1, 2, 3];

alert( arr ); // 1,2,3

alert( String(arr) === '1,2,3' ); // true

### splice 
**удаляет** элемент из массива (и возвращает массив из удалённых элементов)

Например, удалить 3 элемента и заменить их двумя другим:

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");

alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

**добавляет** элементы без удаления:


arr.splice(2, **0**, "сложный", "язык");


*разрешён **отрицательный** индекс

### slice
Он возвращает новый массив, в который копирует все элементы с индекса start до end.

let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

### concat
создаёт новый массив, в который копирует данные из других массивов (и может простые значения)

### forEach
позволяет запускать функцию для каждого элемента массива

## Поиск в массиве

### indexOf
arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1

### includes
arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.

### lastIndexOf
arr.lastIndexOf похож на indexOf, но ищет справа налево

## Преобразование массива
### map
Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
## Сложность алгоритма
**Big O** – сложность алгоритма, показывает его эффективность. 
Пропорция: кол-во операций — размер данных.

**O(1)** описывает константную сложность.

**O(n)** – линейная сложность – количество выполняемых операций, где **n** – количество элементов.
        